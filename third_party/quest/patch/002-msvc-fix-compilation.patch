diff -Npur quest-orig/QuEST/include/QuEST.h quest-src/QuEST/include/QuEST.h
--- quest-orig/QuEST/include/QuEST.h	2022-03-28 15:00:10.245339732 +0200
+++ quest-src/QuEST/include/QuEST.h	2022-03-28 15:12:50.871690505 +0200
@@ -337,31 +337,6 @@ ComplexMatrixN createComplexMatrixN(int
  */
 void destroyComplexMatrixN(ComplexMatrixN matr);
 
-#ifndef __cplusplus
-/** Initialises a ComplexMatrixN instance to have the passed
- * \p real and \p imag values. This allows succint population of any-sized
- * ComplexMatrixN, e.g. through 2D arrays:
- *
- *     ComplexMatrixN m = createComplexMatrixN(3);
- *     initComplexMatrixN(m, 
- *         (qreal[8][8]) {{1,2,3,4,5,6,7,8}, {0}},
- *         (qreal[8][8]) {{0}});
- *
- * \p m can be created by either createComplexMatrixN() or getStaticComplexMatrixN().
- *
- * This function is only callable in C, since C++ signatures cannot
- * contain variable-length 2D arrays 
- *
- * @ingroup type
- * @param[in] m the matrix to initialise
- * @param[in] real matrix of real values; can be 2D array of array of pointers
- * @param[in] imag matrix of imaginary values; can be 2D array of array of pointers
- * @throws invalidQuESTInputError if \p m has not been allocated (e.g. with createComplexMatrixN())
- * @author Tyson Jones
- */
-void initComplexMatrixN(ComplexMatrixN m, qreal real[][1<<m.numQubits], qreal imag[][1<<m.numQubits]);
-#endif 
-
 /** Create a \p PauliHamil instance, which is a Hamiltonian expressed as a real-weighted 
  * sum of products of Pauli operators. This is merely an encapsulation of the multiple 
  * parameters of functions like applyPauliSum().
@@ -3319,84 +3294,6 @@ void multiControlledMultiQubitUnitary(Qu
  */
 void mixKrausMap(Qureg qureg, int target, ComplexMatrix2 *ops, int numOps);
 
-/** Apply a general two-qubit Kraus map to a density matrix, as specified by at most 
- * sixteen Kraus operators. A Kraus map is also referred to as a "operator-sum representation"
- * of a quantum channel. This allows one to simulate a general two-qubit noise process.
- *
- * The Kraus map must be completely positive and trace preserving, which constrains each 
- * \f$ K_i \f$ in \p ops by
- * \f[
-    \sum \limits_i^{\text{numOps}} K_i^\dagger K_i = I
- * \f]
- * where \f$ I \f$ is the identity matrix.
- *
- * \p targetQubit1 is treated as the \p least significant qubit in each op in \p ops.
- *
- * Note that in distributed mode, this routine requires that each node contains at least 16 amplitudes.
- * This means an q-qubit register can be distributed by at most 2^(q-4) numTargs nodes.
- *
- * @ingroup decoherence
- * @param[in,out] qureg the density matrix to which to apply the map
- * @param[in] target1 the least significant target qubit in \p ops
- * @param[in] target2 the most significant target qubit in \p ops
- * @param[in] ops an array of at most 16 Kraus operators
- * @param[in] numOps the number of operators in \p ops which must be >0 and <= 16.
- * @throws invalidQuESTInputError
- *      if \p qureg is not a density matrix, 
- *      or if either \p target1 or \p target2 is outside of [0, \p qureg.numQubitsRepresented),
- *      or if \p target1 = \p target2,
- *      or if \p numOps is outside [1, 16],
- *      or if \p ops do not create a completely positive, trace preserving map,
- *      or if a node cannot fit 16 amplitudes in distributed mode.
- * @author Balint Koczor
- * @author Tyson Jones (refactored, doc)
- */
-void mixTwoQubitKrausMap(Qureg qureg, int target1, int target2, ComplexMatrix4 *ops, int numOps);
-
-/** Apply a general N-qubit Kraus map to a density matrix, as specified by at most (2N)^2
- * Kraus operators. This allows one to simulate a general noise process.
- *
- * The Kraus map must be completely positive and trace preserving, which constrains each 
- * \f$ K_i \f$ in \p ops by
- * \f[
-    \sum \limits_i^{\text{numOps}} K_i^\dagger K_i = I
- * \f]
- * where \f$ I \f$ is the identity matrix.
- *
- * The first qubit in \p targets is treated as the \p least significant qubit in each op in \p ops.
- *
- * Note that in distributed mode, this routine requires that each node contains at least (2N)^2 amplitudes.
- * This means an q-qubit register can be distributed by at most 2^(q-2)/N^2 nodes.
- *
- * Note too that this routine internally creates a 'superoperator'; a complex matrix of dimensions
- * 2^(2*numTargets) by 2^(2*numTargets). Therefore, invoking this function incurs, 
- * for numTargs={1,2,3,4,5, ...}, an additional memory overhead of (at double-precision)
- * {0.25 KiB, 4 KiB, 64 KiB, 1 MiB, 16 MiB, ...} (respectively).
- * At quad precision (usually 10 B per number, but possibly 16 B due to alignment),
- * this costs at most double the amount of memory. 
- * For numTargets < 4, this superoperator will be created in the runtime 
- * stack. For numTargs >= 4, the superoperator will be allocated in the heap and 
- * therefore this routine may suffer an anomalous slowdown.
- *
- * @ingroup decoherence
- * @param[in,out] qureg the density matrix to which to apply the map
- * @param[in] targets a list of target qubit indices, the first of which is treated as least significant in each op in \p ops
- * @param[in] numTargets the length of \p targets
- * @param[in] ops an array of at most (2N)^2 Kraus operators
- * @param[in] numOps the number of operators in \p ops which must be >0 and <= (2N)^2.
- * @throws invalidQuESTInputError
- *      if \p qureg is not a density matrix, 
- *      or if any target in \p targets is outside of [0, \p qureg.numQubitsRepresented),
- *      or if any qubit in \p targets is repeated,
- *      or if \p numOps is outside [1, (2 \p numTargets)^2],
- *      or if any ComplexMatrixN in \ops does not have op.numQubits == \p numTargets,
- *      or if \p ops do not create a completely positive, trace preserving map,
- *      or if a node cannot fit (2N)^2 amplitudes in distributed mode.
- * @author Tyson Jones
- * @author Balint Koczor
- */
-void mixMultiQubitKrausMap(Qureg qureg, int* targets, int numTargets, ComplexMatrixN* ops, int numOps);
-
 /** Computes the Hilbert Schmidt distance between two density matrices \p a and \p b, 
  * defined as the Frobenius norm of the difference between them.
  * That is, we define the Hilbert Schmidt distance
@@ -3823,51 +3720,6 @@ extern "C" void invalidQuESTInputError(c
  */
 void invalidQuESTInputError(const char* errMsg, const char* errFunc);
  
-#ifndef __cplusplus
- // hide this function from doxygen
- /// \cond HIDDEN_SYMBOLS
-/** Creates a ComplexMatrixN struct with .real and .imag arrays kept entirely 
- * in the stack. 
- * This function should not be directly called by the user; instead, users should 
- * call the macro getStaticComplexMatrixN.
- *
- * The passed 'reStorage' and 'imStorage' must be arrays with 
- * length (1<<numQubits) and are populated with pointers to rows of the 2D 
- * arrays 're' and 'im', and then attached to the returned ComplexMatrixN instance.
- * For example:
- *
- *     ComplexMatrixN m = bindArraysToStackComplexMatrixN(
- *         1, 
- *         (qreal[][2]) {{1,0},{0,1}}, (qreal[][2]) {{0}}, 
- *         (qreal*[2]) {0}, (qreal*[2]) {0}
- *     );
- *
- * Note that this ComplexMatrixN instance, since kept in the stack, cannot be *returned*
- * beyond the calling scope which would result in a dangling pointer.
- * This is unlike a ComplexMatrixN instance created with createComplexMatrixN, which 
- * is dynamic (lives in heap) and can be returned, through needs explicit freeing 
- * with destroyComplexMatrixN.
- *
- * This function is only callable in C, since C++ signatures cannot contain 
- * variable-length 2D arrays.
- *
- * @ingroup type
- * @param[in] numQubits the number of qubits that the ComplexMatrixN corresponds to.
- *  note the .real and .imag arrays of the returned ComplexMatrixN will have 
- *  2^numQubits rows and columns.
- * @param[in] re a 2D array (2^numQubits by 2^numQubits) of the real components
- * @param[in] im a 2D array (2^numQubits by 2^numQubits) of the imag components
- * @param[in] reStorage a 1D array of length 2^numQubits
- * @param[in] imStorage a 1D array of length 2^numQubits
- * @returns a ComplexMatrixN struct with stack-stored .real and .imag arrays,
- *  which are actually the passed \p reStorage and \p imStorage arrays, populated 
- *  with pointers to the rows of \p re and \p im
- * @author Tyson Jones
- */
-ComplexMatrixN bindArraysToStackComplexMatrixN(
-    int numQubits, qreal re[][1<<numQubits], qreal im[][1<<numQubits], 
-    qreal** reStorage, qreal** imStorage);
-#endif
 /// \endcond
 
 // hide this function from doxygen
diff -Npur quest-orig/QuEST/src/QuEST.c quest-src/QuEST/src/QuEST.c
--- quest-orig/QuEST/src/QuEST.c	2022-03-28 15:00:10.245339732 +0200
+++ quest-src/QuEST/src/QuEST.c	2022-03-28 15:12:35.481629007 +0200
@@ -1072,26 +1072,6 @@ void mixKrausMap(Qureg qureg, int target
         "Here, an undisclosed Kraus map was effected on qubit %d", target);
 }
 
-void mixTwoQubitKrausMap(Qureg qureg, int target1, int target2, ComplexMatrix4 *ops, int numOps) {
-    validateDensityMatrQureg(qureg, __func__);
-    validateMultiTargets(qureg, (int[]) {target1,target2}, 2, __func__);
-    validateTwoQubitKrausMap(qureg, ops, numOps, __func__);
-    
-    densmatr_mixTwoQubitKrausMap(qureg, target1, target2, ops, numOps);
-    qasm_recordComment(qureg, 
-        "Here, an undisclosed two-qubit Kraus map was effected on qubits %d and %d", target1, target2);
-}
-
-void mixMultiQubitKrausMap(Qureg qureg, int* targets, int numTargets, ComplexMatrixN* ops, int numOps) {
-    validateDensityMatrQureg(qureg, __func__);
-    validateMultiTargets(qureg, targets, numTargets, __func__);
-    validateMultiQubitKrausMap(qureg, numTargets, ops, numOps, __func__);
-    
-    densmatr_mixMultiQubitKrausMap(qureg, targets, numTargets, ops, numOps);
-    qasm_recordComment(qureg,
-        "Here, an undisclosed %d-qubit Kraus map was applied to undisclosed qubits", numTargets);
-}
-
 /*
  * other data structures 
  */
@@ -1133,17 +1113,6 @@ void destroyComplexMatrixN(ComplexMatrix
     free(m.imag);
 }
 
-void initComplexMatrixN(ComplexMatrixN m, qreal re[][1<<m.numQubits], qreal im[][1<<m.numQubits]) {
-    validateMatrixInit(m, __func__);
-    
-    int dim = 1 << m.numQubits;
-    for (int i=0; i<dim; i++)
-        for (int j=0; j<dim; j++) {
-            m.real[i][j] = re[i][j];
-            m.imag[i][j] = im[i][j];
-        }
-}
-
 PauliHamil createPauliHamil(int numQubits, int numSumTerms) {
     validateHamilParams(numQubits, numSumTerms, __func__);
     
diff -Npur quest-orig/QuEST/src/QuEST_common.c quest-src/QuEST/src/QuEST_common.c
--- quest-orig/QuEST/src/QuEST_common.c	2022-03-28 15:00:10.245339732 +0200
+++ quest-src/QuEST/src/QuEST_common.c	2022-03-28 15:12:15.644883092 +0200
@@ -604,75 +604,6 @@ void densmatr_mixKrausMap(Qureg qureg, i
     densmatr_applyKrausSuperoperator(qureg, target, superOp);
 }
 
-ComplexMatrixN bindArraysToStackComplexMatrixN(
-    int numQubits, qreal re[][1<<numQubits], qreal im[][1<<numQubits], 
-    qreal** reStorage, qreal** imStorage
-) {
-    ComplexMatrixN m;
-    m.numQubits = numQubits;
-    m.real = reStorage;
-    m.imag = imStorage;
-    
-    int len = 1<<numQubits;
-    for (int i=0; i<len; i++) {
-        m.real[i] = re[i];
-        m.imag[i] = im[i];
-    }
-    return m;
-}
-#define macro_initialiseStackComplexMatrixN(matrix, numQubits, real, imag) \
-    /* reStorage_ and imStorage_ must not exist in calling scope */ \
-    qreal* reStorage_[1<<(numQubits)]; \
-    qreal* imStorage_[1<<(numQubits)]; \
-    matrix = bindArraysToStackComplexMatrixN((numQubits), real, imag, reStorage_, imStorage_);
-
-#define macro_allocStackComplexMatrixN(matrix, numQubits) \
-    /* reArr_, imArr_, reStorage_, and imStorage_ must not exist in calling scope */ \
-    qreal reArr_[1<<(numQubits)][1<<(numQubits)]; \
-    qreal imArr_[1<<(numQubits)][1<<(numQubits)]; \
-    macro_initialiseStackComplexMatrixN(matrix, (numQubits), reArr_, imArr_);
-
-void densmatr_mixTwoQubitKrausMap(Qureg qureg, int target1, int target2, ComplexMatrix4 *ops, int numOps) {
-    
-    ComplexMatrixN superOp;
-    macro_allocStackComplexMatrixN(superOp, 4);
-    populateKrausSuperOperator4(&superOp, ops, numOps);
-    densmatr_applyTwoQubitKrausSuperoperator(qureg, target1, target2, superOp);
-}
-
-void densmatr_mixMultiQubitKrausMap(Qureg qureg, int* targets, int numTargets, ComplexMatrixN* ops, int numOps) {
-
-    ComplexMatrixN superOp;
-    
-    /* superOp will contain 2^(4 numTargets) complex numbers.
-     * At double precision, superOp will cost additional memory:
-     * numTargs=1   ->   0.25 KiB
-     * numTargs=2   ->   4 KiB 
-     * numTargs=3   ->   64 KiB
-     * numTargs=4   ->   1 MiB
-     * numTargs=5   ->   16 MiB.
-     * At quad precision (usually 10 B per number, but possibly 16 B due to alignment),
-     * this costs at most double.
-     *
-     * Hence, if superOp is kept in the stack, numTargs >= 4 would exceed Windows' 1 MB 
-     * maximum stack-space allocation (numTargs >= 5 exceeding Linux' 8 MB). Therefore, 
-     * for numTargets < 4, superOp will be kept in the stack, else in the heap
-     */
-     
-    if (numTargets < 4) {
-        // everything must live in 'if' since this macro declares local vars
-        macro_allocStackComplexMatrixN(superOp, 2*numTargets);
-        populateKrausSuperOperatorN(&superOp, ops, numOps);
-        densmatr_applyMultiQubitKrausSuperoperator(qureg, targets, numTargets, superOp);
-    }
-    else {
-        superOp = createComplexMatrixN(2*numTargets);
-        populateKrausSuperOperatorN(&superOp, ops, numOps);
-        densmatr_applyMultiQubitKrausSuperoperator(qureg, targets, numTargets, superOp);
-        destroyComplexMatrixN(superOp);
-    }
-}
-
 void densmatr_mixPauli(Qureg qureg, int qubit, qreal probX, qreal probY, qreal probZ) {
     
     // convert pauli probabilities into Kraus map
diff -Npur quest-orig/QuEST/src/QuEST_internal.h quest-src/QuEST/src/QuEST_internal.h
--- quest-orig/QuEST/src/QuEST_internal.h	2022-03-28 15:00:10.245339732 +0200
+++ quest-src/QuEST/src/QuEST_internal.h	2022-03-28 15:12:27.504930471 +0200
@@ -96,10 +96,6 @@ void densmatr_mixDensityMatrix(Qureg com
 
 void densmatr_mixKrausMap(Qureg qureg, int target, ComplexMatrix2 *ops, int numOps);
 
-void densmatr_mixTwoQubitKrausMap(Qureg qureg, int target1, int target2, ComplexMatrix4 *ops, int numOps);
-
-void densmatr_mixMultiQubitKrausMap(Qureg qureg, int* targets, int numTargets, ComplexMatrixN* ops, int numOps);
-
 void densmatr_applyDiagonalOp(Qureg qureg, DiagonalOp op);
 
 Complex densmatr_calcExpecDiagonalOp(Qureg qureg, DiagonalOp op);
diff -Npur quest-orig/tests/test_decoherence.cpp quest-src/tests/test_decoherence.cpp
--- quest-orig/tests/test_decoherence.cpp	2022-03-28 15:00:10.278673196 +0200
+++ quest-src/tests/test_decoherence.cpp	2022-03-28 15:13:21.871814415 +0200
@@ -222,219 +222,6 @@ TEST_CASE( "mixDepolarising", "[decohere
 
 
 
-/** @sa mixMultiQubitKrausMap
- * @ingroup unittest 
- * @author Tyson Jones 
- */
-TEST_CASE( "mixMultiQubitKrausMap", "[decoherence]" ) {
-    
-    PREPARE_TEST(qureg, ref);
-    
-    // figure out max-num (inclusive) targs allowed by hardware backend
-    // (each node must contain as 2^(2*numTargs) amps)
-    int maxNumTargs = calcLog2(qureg.numAmpsPerChunk) / 2;
-    
-    SECTION( "correctness" ) {
-        
-        /* note that this function incurs a stack overhead when numTargs < 4,
-         * and a heap overhead when numTargs >= 4
-         */
-         
-        int numTargs = GENERATE_COPY( range(1,maxNumTargs+1) ); // inclusive upper bound
-        
-        // note this is very expensive to try every arrangement (2 min runtime for numTargs=5 alone)
-        int* targs = GENERATE_COPY( sublists(range(0,NUM_QUBITS), numTargs) );
-        
-        // try the min and max number of operators, and 2 random numbers 
-        // (there are way too many to try all!)
-        int maxNumOps = (2*numTargs)*(2*numTargs);
-        int numOps = GENERATE_COPY( 1, maxNumOps, take(2,random(1,maxNumOps)) );
-        
-        // use a new random map
-        std::vector<QMatrix> matrs = getRandomKrausMap(numTargs, numOps);
-                
-        // create map in QuEST datatypes
-        ComplexMatrixN ops[numOps];
-        for (int i=0; i<numOps; i++) {
-            ops[i] = createComplexMatrixN(numTargs);
-            toComplexMatrixN(matrs[i], ops[i]);
-        }
-                
-        mixMultiQubitKrausMap(qureg, targs, numTargs, ops, numOps);
-                
-        // set ref -> K_i ref K_i^dagger
-        QMatrix matrRefs[numOps];
-        for (int i=0; i<numOps; i++) {
-            matrRefs[i] = ref;
-            applyReferenceOp(matrRefs[i], targs, numTargs, matrs[i]);
-        }
-        ref = getZeroMatrix(ref.size());
-        for (int i=0; i<numOps; i++)
-            ref += matrRefs[i];
-        
-        REQUIRE( areEqual(qureg, ref, 1E2*REAL_EPS) );
-        
-        // cleanup QuEST datatypes
-        for (int i=0; i<numOps; i++)
-            destroyComplexMatrixN(ops[i]);
-    }
-    SECTION( "input validation" ) {
-        
-        SECTION( "repetition of target" ) {
-            
-            // make valid targets
-            int targs[NUM_QUBITS];
-            for (int i=0; i<NUM_QUBITS; i++)
-                targs[i] = i;
-                
-            // duplicate one
-            int badInd = GENERATE( range(0,NUM_QUBITS) );
-            int copyInd = GENERATE_COPY( filter([=](int i){ return i!=badInd; }, range(0,NUM_QUBITS)) );
-            targs[badInd] = targs[copyInd];
-            
-            REQUIRE_THROWS_WITH( mixMultiQubitKrausMap(qureg, targs, NUM_QUBITS, NULL, 1), Contains("target qubits") && Contains("unique") );
-        }
-        SECTION( "qubit indices" ) { 
-            
-            // make valid targets
-            int targs[NUM_QUBITS];
-            for (int i=0; i<NUM_QUBITS; i++)
-                targs[i] = i;
-            
-            // make one invalid 
-            targs[GENERATE( range(0,NUM_QUBITS) )] = GENERATE( -1, NUM_QUBITS );
-            
-            REQUIRE_THROWS_WITH( mixMultiQubitKrausMap(qureg, targs, NUM_QUBITS, NULL, 1), Contains("Invalid target qubit") );
-        }
-        SECTION( "number of operators" ) {
-            
-            int numTargs = GENERATE_COPY( range(1,maxNumTargs+1) );
-            int maxNumOps = (2*numTargs)*(2*numTargs);
-            int numOps = GENERATE_REF( -1, 0, maxNumOps + 1 );
-                        
-            // make valid targets to avoid triggering target validation
-            int targs[numTargs];
-            for (int i=0; i<numTargs; i++)
-                targs[i] = i;
-            REQUIRE_THROWS_WITH( mixMultiQubitKrausMap(qureg, targs, numTargs, NULL, numOps), Contains("operators may be specified") );
-        }
-        SECTION( "initialisation of operators" ) {
-            
-            /* compilers don't auto-initialise to NULL; the below circumstance 
-             * only really occurs when 'malloc' returns NULL in createComplexMatrixN, 
-             * which actually triggers its own validation. Hence this test is useless 
-             * currently.
-             */
-             
-            int numTargs = NUM_QUBITS;
-            int numOps = (2*numTargs)*(2*numTargs);
-            
-            // no need to initialise ops, but set their attribs correct to avoid triggering other validation
-            ComplexMatrixN ops[numOps];
-            for (int i=0; i<numOps; i++)
-                ops[i].numQubits = numTargs;
-            
-            // make one of the max-ops explicitly NULL
-            ops[GENERATE_COPY( range(0,numTargs) )].real = NULL;
-             
-            // make valid targets to avoid triggering target validation
-            int targs[numTargs];
-            for (int i=0; i<numTargs; i++)
-                targs[i] = i;
-               
-            REQUIRE_THROWS_WITH( mixMultiQubitKrausMap(qureg, targs, numTargs, ops, numOps), Contains("ComplexMatrixN") && Contains("created") );
-        }
-        SECTION( "dimension of operators" ) {
-        
-            // make valid (dimension-wise) max-qubits Kraus map
-            int numTargs = NUM_QUBITS;
-            int numOps = (2*numTargs)*(2*numTargs);
-            ComplexMatrixN ops[numOps];
-            for (int i=0; i<numOps; i++)
-                ops[i] = createComplexMatrixN(numTargs);
-            
-            // make one have wrong-dimensions 
-            int badInd = GENERATE_COPY( range(0,numTargs) );
-            destroyComplexMatrixN(ops[badInd]);
-            ops[badInd] = createComplexMatrixN(numTargs - 1);
-            
-            // make valid targets to avoid triggering target validation
-            int targs[numTargs];
-            for (int i=0; i<numTargs; i++)
-                targs[i] = i;
-                
-            REQUIRE_THROWS_WITH( mixMultiQubitKrausMap(qureg, targs, numTargs, ops, numOps), Contains("same number of qubits") );
-            
-            for (int i=0; i<numOps; i++)
-                destroyComplexMatrixN(ops[i]);
-        }
-        SECTION( "trace preserving" ) {
-            
-            int numTargs = GENERATE_COPY( range(1,maxNumTargs+1) );
-            int maxNumOps = (2*numTargs) * (2*numTargs);
-            int numOps = GENERATE_COPY( 1, 2, maxNumOps );
-            
-            // generate a valid map
-            std::vector<QMatrix> matrs = getRandomKrausMap(numTargs, numOps);
-            ComplexMatrixN ops[numOps];
-            for (int i=0; i<numOps; i++) {
-                ops[i] = createComplexMatrixN(numTargs);
-                toComplexMatrixN(matrs[i], ops[i]);
-            }
-            
-            // make only one invalid
-            ops[GENERATE_REF( range(0,numOps) )].real[0][0] = 0;
-            
-            // make valid targets to avoid triggering target validation
-            int targs[numTargs];
-            for (int i=0; i<numTargs; i++)
-                targs[i] = i;
-            
-            REQUIRE_THROWS_WITH( mixMultiQubitKrausMap(qureg, targs, numTargs, ops, numOps), Contains("trace preserving") );
-
-            for (int i=0; i<numOps; i++)
-                destroyComplexMatrixN(ops[i]);
-        }
-        SECTION( "density-matrix" ) {
-            
-            Qureg statevec = createQureg(NUM_QUBITS, QUEST_ENV);
-            
-            // make valid targets to avoid triggering target validation
-            int targs[NUM_QUBITS];
-            for (int i=0; i<NUM_QUBITS; i++)
-                targs[i] = i;
-                
-            REQUIRE_THROWS_WITH( mixMultiQubitKrausMap(statevec, targs, NUM_QUBITS, NULL, 1), Contains("valid only for density matrices") );
-            destroyQureg(statevec, QUEST_ENV);
-            
-        }
-        SECTION( "operator fits in node" ) {
-            
-            // each node requires (2 numTargs)^2 amplitudes
-            int minAmps = (2*NUM_QUBITS) * (2*NUM_QUBITS);
-            
-            // make valid targets to avoid triggering target validation
-            int targs[NUM_QUBITS];
-            for (int i=0; i<NUM_QUBITS; i++)
-                targs[i] = i;
-            
-            // make a simple Identity map    
-            ComplexMatrixN ops[] = {createComplexMatrixN(NUM_QUBITS)};
-            for (int i=0; i<(1<<NUM_QUBITS); i++)
-                ops[0].real[i][i] = 1;
-            
-            // fake a smaller qureg 
-            qureg.numAmpsPerChunk = minAmps - 1;
-            REQUIRE_THROWS_WITH( mixMultiQubitKrausMap(qureg, targs, NUM_QUBITS, ops, 1), Contains("targets too many qubits") && Contains("cannot all fit") );
-            
-            destroyComplexMatrixN(ops[0]);
-        }
-    }
-    destroyQureg(qureg, QUEST_ENV);
-}
-
-
-
 /** @sa mixPauli
  * @ingroup unittest 
  * @author Tyson Jones 
@@ -713,82 +500,3 @@ TEST_CASE( "mixTwoQubitDepolarising", "[
 
 
 
-/** @sa mixTwoQubitKrausMap
- * @ingroup unittest 
- * @author Tyson Jones 
- */
-TEST_CASE( "mixTwoQubitKrausMap", "[decoherence]" ) {
-    
-    PREPARE_TEST(qureg, ref);
-    
-    SECTION( "correctness" ) {
-        
-        int targ1 = GENERATE( range(0,NUM_QUBITS) );
-        int targ2 = GENERATE_COPY( filter([=](int t){ return t!=targ1; }, range(0,NUM_QUBITS)) );
-        int numOps = GENERATE( range(1,17) ); // max 16 inclusive
-        std::vector<QMatrix> matrs = getRandomKrausMap(2, numOps);
-        
-        ComplexMatrix4 ops[numOps];
-        for (int i=0; i<numOps; i++)
-            ops[i] = toComplexMatrix4(matrs[i]);
-        mixTwoQubitKrausMap(qureg, targ1, targ2, ops, numOps);
-        
-        // set ref -> K_i ref K_i^dagger
-        int targs[2] = {targ1, targ2};
-        QMatrix matrRefs[numOps];
-        for (int i=0; i<numOps; i++) {
-            matrRefs[i] = ref;
-            applyReferenceOp(matrRefs[i], targs, 2, matrs[i]);
-        }
-        ref = getZeroMatrix(ref.size());
-        for (int i=0; i<numOps; i++)
-            ref += matrRefs[i];
-        
-        REQUIRE( areEqual(qureg, ref, 10*REAL_EPS) );
-    }
-    SECTION( "input validation" ) {
-        
-        SECTION( "number of operators" ) {
-            
-            int numOps = GENERATE( 0, 17 );
-            REQUIRE_THROWS_WITH( mixTwoQubitKrausMap(qureg, 0,1, NULL, numOps), Contains("operators") );
-        }
-        SECTION( "trace preserving" ) {
-            
-            // valid Kraus map
-            int numOps = GENERATE( range(1,16) );
-            std::vector<QMatrix> matrs = getRandomKrausMap(2, numOps);
-            ComplexMatrix4 ops[numOps];
-            for (int i=0; i<numOps; i++)
-                ops[i] = toComplexMatrix4(matrs[i]);
-                
-            // make only one of the ops at a time invalid
-            ops[GENERATE_REF( range(0,numOps) )].real[0][0] = 0;
-            REQUIRE_THROWS_WITH( mixTwoQubitKrausMap(qureg, 0,1, ops, numOps), Contains("trace preserving") );
-        }
-        SECTION( "target collision" ) {
-            
-            int target = GENERATE( range(0,NUM_QUBITS) );
-            REQUIRE_THROWS_WITH( mixTwoQubitKrausMap(qureg, target, target, NULL, 1), Contains("target qubits") && Contains("unique") );
-        }
-        SECTION( "qubit index" ) {
-            
-            int target = GENERATE( -1, NUM_QUBITS );
-            REQUIRE_THROWS_WITH( mixTwoQubitKrausMap(qureg, 0,target, NULL, 1), Contains("Invalid target qubit") );
-            REQUIRE_THROWS_WITH( mixTwoQubitKrausMap(qureg, target,0, NULL, 1), Contains("Invalid target qubit") );
-        }
-        SECTION( "density-matrix" ) {
-            
-            Qureg vec = createQureg(NUM_QUBITS, QUEST_ENV);
-            REQUIRE_THROWS_WITH( mixTwoQubitKrausMap(vec, 0,1, NULL, 1), Contains("density matrices") );
-            destroyQureg(vec, QUEST_ENV);
-        }
-        SECTION( "operators fit in node" ) {
-            
-            qureg.numAmpsPerChunk = 15; // min 16
-            REQUIRE_THROWS_WITH( mixTwoQubitKrausMap(qureg, 0,1, NULL, 1), Contains("targets too many qubits") );
-        }        
-    }
-    destroyQureg(qureg, QUEST_ENV);
-}
-
